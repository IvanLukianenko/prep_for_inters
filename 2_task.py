# 2. Дан массив целых чисел - длин отрезков, нужно выбрать максимальное число отрезков из этого массива так, 
# чтобы из любых трех можно было составить невырожденный треугольник. 
# O(N log N)


"""
Докажем тот факт, что в отсортированном массиве, тот подмассив отрезков, будет "сплошной"
Допустим, что есть массив a = [a1, a2, a3, a4, a5, a6, a7], найдем подмассив s = [a2, a3, a5, a6], 
но т.к. для любых двух элементов найденного подмассивв верно, что их сумма больше любого элемента.
Например, a2+a3 > a5, но в то же время, a5>a4 => a4 то же лежит в s. От этого будет и отталкиваться.
И пусть все элементы массива разные.
Если одинаковые, то заведем структуру, где будет хранить количество для каждого элемента
"""
def bin_search(M, s):
    l = 0
    r = len(M) - 1
    
    while r - l >= 1:
        m = (r+l)//2
        if (s > M[m]):
            l = m+1
        if (s <= M[m]):
            r = m
        
    return m+3


if __name__ == "__main__":
    M = [1, 2, 6, 7, 5, 4, 3]
    M = sorted(M)
    max = 0
    for i in range(len(M)-3):
        k = bin_search(M[i+2:],M[i]+M[i+1])
        if max < k:
            max = k
    print(max)
    print(M)
